/*
    本题是真正让你解决数独问题了..并且题目假设给的数独矩阵一定有解且解是唯一的。
    基本想法就是回溯法

*/

public class Solution {
    	public void solveSudoku(char[][] board) {
		if(board.length == 0) return;	
        boolean canbeSolved = resolveSudoku(board);
//      System.out.println("Can be resolved? " + canbeSolved);
    }
	
	public boolean resolveSudoku(char[][] board) {
		for(int i=0; i<9; i++) {
        	for(int j=0; j<9; j++) {
        		if(board[i][j] == '.') {
        			String possible = getPossibleNumber(board, i, j); // get available possible number range
        			for(int k=0; k<possible.length(); k++) {
        				// put possible.charAt(k) in board[i][j], and perform recursion again
        				board[i][j] = possible.charAt(k);
        				if(resolveSudoku(board) == true) return true; // can be resolved with current possibility
        				else board[i][j] = '.'; // cannot be resolved, then roll back
        			}
        			// all possible numbers in current number range can not solve the Sodoku, then roll back with returning false
        			return false;
        		}
        	}
        }
		return true;
    }
	
	public String getPossibleNumber(char[][] board, int x, int y) {
		//x: index of row, get possible number for row
		String appe = "", rec = "";
		for(int i=0; i<9; i++) {
			if(board[x][i] != '.') 
				appe += board[x][i];
		}
		//y:index of column, get possible number for column
		for(int i=0; i<9; i++) {
			if(board[i][y] != '.') 
				appe += board[i][y];
		}
		// check possible number for square
		for(int i=3*(x/3); i<3*(x/3)+3; i++) {
			for(int j=3*(y/3); j<3*(y/3)+3; j++) {
				if(board[i][j] != '.') 
					appe += board[i][j];
			}
		}
		//get the non-appear number (possible number)
		for(int i=1; i<=9; i++) {
			if(!appe.contains("" + i)) {
				rec += ("" + i);
			}
		}	
		return rec;
	}
}
